/* 需求：统计1-90000000之间的素数
传统方法：循环
使用并发或者并行的方式，将统计任务分配给多个goroutine去完成

并发：因为是在一个cpu上，比如有10个线程，每个线程执行10毫秒（进行轮询操作），从人的角度看，好像这10个线程都在运行，
但是从微观上看，在某一个时间点看，其实只有一个线程在执行，这就是并发。

并行：因为是在多个cpu上（比如有10个cpu），比如有10个线程，每个线程执行10毫秒（各自在不同cpu上执行），从人的角度看，
这10个线程都在运行，但是从微观上看，在某一个时间点看，也同时有10个线程在执行，这就是并行。

Go主线程(有程序员直接称为线程/也可以理解成进程): 一个Go线程上，可以起多个协程，你可以 这样理解，协程是轻量级的线程[编译器做优化]。
主线程：进程
协程：轻量级线程

*/

package main
import (
	"fmt"
	"strconv"
	"time"
)


//主线程结束后即使协程还没有执行完依旧会退出，当协程执行完毕以后主线程还没结束依旧会执行
//主线程是一个物理线程，直接作用在cpu上，是重量级的，非常消耗cpu资源
//协程从主线程开启的，是轻量级的消耗小
//golang的协程机制是重要的特点，可以轻松开启上万个协程，对于其他语言基于并发的，就凸现出golang在并发上的优势
//go协程特点：1.有独立的栈空间 2.共享程序堆空间 3.调度用户控制


//快速入门
//在主线程(可以理解成进程)中，开启一个goroutine, 该协程每隔1秒输出 "hello,world"
// 在主线程中也每隔一秒输出"hello,golang", 输出10次后，退出程序
// 要求主线程和goroutine同时执行

//协程一般以函数为单位进行开启
func test(){
	for i:=1;i<10;i++{
		fmt.Println("test() helloworld" + strconv.Itoa(i))
        time.Sleep(time.Second)
	}
}


func main(){

	go test()//开启协程，要加go

	for i:=1;i<10;i++{
		fmt.Println("helloworld golang" + strconv.Itoa(i))
        time.Sleep(time.Second)
	}
}


/*MPG模式 M操作系统主线程（物理线程）P协程执行所需要的上下文，资源，G协程
go协程是轻量级的，是逻辑态的，c/java多线程往往是内核态的，比较重量级。
M运行在相同的CPU就为并发，作用在不同的cpu就是并行  
MPG调度模式，可以既让GO执行，同时也不会让队列的其他协程一直阻塞，任然可以并发执行
 */   